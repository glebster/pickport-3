# 18 — Концепция List (связанные записи)

Этот документ описывает, когда и как использовать `List` как отдельную сущность, как связывать записи, и какие практики лучше работают для чеков, совместных оплат и «пачек» событий.

## Зачем нужен List

`List` — это контейнер для набора связанных `Entry`, которые:

- возникли из одного источника (чек, событие, поездка, семейный поход);
- имеют общий контекст (дата, место, люди);
- должны отображаться как единый «пакет» с итогами и деталями.

Смысл `List` — не заменить `Entry`, а дать структуру для «пачек»: смотреть итог, углубляться в детали и не терять связь между событиями.

## Базовая модель

### List как сущность

Минимальный набор полей:

- `id` — уникальный идентификатор.
- `title` — человекочитаемое название списка (например, «Пиццерия на Арбате» или «Поход в магазин, 12 мая»).
- `summary` (optional) — агрегированное описание (итоги суммы, количество позиций, краткое резюме).
- `source` (optional) — источник (чек, импорт, ручной ввод, фото).

### Связь с Entry

Каждая запись может иметь поле `listId`. Это **признак** принадлежности записи к списку.

Выбираем **один** способ связи (без дублирования):

- **Вариант A (рекомендуемый):** `Entry.listId` — ключевая связь. Список формируется фильтром по `listId`.
- **Вариант B:** `List.entries[]` хранит ссылки на записи. В этом случае `Entry.listId` не обязателен.

Общий контекст списка получаем, когда нужно, **из самих `Entry`**: берём список и все его записи, и этого достаточно для полного контекста.

## Как формировать List

### Когда List нужен

Создаём `List`, если:

1. Из одного входа рождается несколько записей (чек, списание по людям, поездка, заказ с позициями).
2. Пользователю нужен обзор «пакета» и его итога (сумма, участники, покупки).
3. События логически связаны и имеют общий контекст.

### Когда List не нужен

Не создаём `List`, если:

- это одиночное событие без «разветвления» (не плодим `List` ради одной записи);
- не требуется контекстный просмотр пакета;
- детали не нужны (например, краткая заметка о посещении, без покупки и без участников).

## Пример: пиццерия и долги

**Сценарий:** «Сходил в классную пиццерию. Заплатил за Олега 100 и за Витю 100.»

**Рекомендуемая модель:**

- `List`:
  - `title`: «Пиццерия, ужин»
- `Entry #1`: `visited/place` — посещение места, оценка, заметка, фото.
- `Entry #2`: `lent/money` — долг Олегу на 100.
- `Entry #3`: `lent/money` — долг Вите на 100.

**Зачем так:**

- В списке видно единое событие и все финансовые последствия.
- Список несёт эмоциональный контекст, а долги — детализацию.

## Пример: чек и покупки

Есть два подхода:

### Вариант A: Разбор чека в записи

- Создаём `List`.
- `Entry #1` — «поход в магазин» (место, дата, общая сумма).
- Каждая позиция чека — отдельная `Entry` (`bought/item`, с количеством и ценой).

**Плюсы:**

- Прозрачная аналитика по позициям.
- Можно искать «где покупал молоко».

**Минусы:**

- Много записей, может шуметь.
- Требует уверенного парсинга.

### Вариант B: Чек как артефакт

- Создаём только одну `Entry` «поход в магазин».
- `attachments` содержит `json` чека или распознанные данные.

**Плюсы:**

- Быстрее и чище для пользователя.
- Нет лишнего шума в ленте.

**Минусы:**

- Сложнее искать по позиции.
- Потеря гранулярности.

### Рекомендуемая практика (Best practice)

**Гибридная стратегия:**

1. Если из ввода получается **одна запись**, создаём **только `Entry`** и сохраняем чек как артефакт в `attachments`.
2. Если распознано **несколько позиций**, создаём `List` и отдельные `Entry` по позициям.
3. Общий контекст берём из набора записей списка, не дублируя его на уровне `List`.
4. UI показывает список как «пачку»: сверху итог, ниже — позиции (если есть), иначе кнопка «показать чек».

Таким образом, продукт остаётся простым для пользователя, но хранит детализацию там, где это действительно полезно.

## Контекст списка и записи

Чтобы не дублировать данные:

- `List` хранит только идентификатор и мета‑уровень (например, `title`).
- Полный контекст получается при запросе `List + Entry[]`: поля лежат в записях, а не в списке.
- В `Entry` остаётся только собственный контекст, специфичный для записи (например, позиция, сумма, персона для долга).

### Как собирать общий контекст из Entry

Когда нужен «общий» контекст списка (например, для карточки списка), его можно **вывести** из набора записей:

- `date`: берём минимальную/среднюю дату или дату первой записи.
- `placeText`: если совпадает у большинства записей — показываем; иначе скрываем.
- `people`: объединяем уникальных участников.
- `currency`: если везде одинаковая — показываем; если нет — скрываем и показываем «несколько валют».

Такой выводимый контекст **не хранится** в `List`, а вычисляется на лету.

## Рекомендации по UX

- Возможность создать `List` вручную: при вводе записи можно выбрать существующий список или создать новый.
- Отдельный экран «Списки» с навигацией по наборам.
- В ленте `Entry` можно переключаться между плоским видом и группировкой по `List`.
- На карточке `List` показывать **итоговую сумму** и **количество записей**.
- Быстрое раскрытие: тапом открывается список записей.
- В ленте `Entry` не должна теряться связь с `List` (бейдж/цвет/иконка).

## Ключевые правила

1. `List` создаётся только при появлении **двух и более** связанных записей.
2. Общий контекст не дублируется на уровне списка — он читается из `Entry`.
3. Гранулярность записей зависит от **уверенности парсинга** и **полезности поиска**.
4. `List` — это **контейнер**, а не новый тип события.
5. Итоги (`summary`) можно считать из `Entry` и сохранять только если нужно для быстрого рендера.
